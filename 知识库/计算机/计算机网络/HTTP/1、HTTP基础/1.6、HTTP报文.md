---
tags:
  - HTTP
  - HTTP报文
  - HTTP请求方法
  - HTTP安全
  - HTTP扩展请求方法
  - URI/URL
  - HTTP状态码
---
![[Pasted image 20231029105548.png]]
# 1、HTTP报文结构

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

- `起始行`：描述请求或响应的基本信息
- `头部字段集合`：使用 key-value 形式更详细地说明报文
- `消息正文`：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。这其中前两部分起始行和头部字段经常又合称为`请求头`或`响应头`，消息正文又称为`实体`，但与`header`对应，很多时候就直接称为`body`。

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个`CRLF`，十六进制的0D0A，所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body 之间有一个`CRLF`。
![[Pasted image 20231029110110.png]]
## 1.2、起始行

### 1.2.1、请求行

请求行由三部分构成：

- `请求方法`：是一个动词，如 `GET`/`POST`，表示对资源的操作；
- `请求目标`：通常是一个 `URI`，标记了请求方法要操作的资源；
- `版本号`：表示报文使用的 HTTP 协议版本。
![[Pasted image 20231029110157.png]]
### 1.2.2、状态行

响应报文里的起始行不叫响应行，而是叫`状态行`，意思是服务器响应的状态。比起请求行来说，状态行要简单一些，同样也是由三部分构成：

- `版本号`：表示报文使用的 HTTP 协议版本；
- `状态码`：一个三位数，用代码的形式表示处理的结果；
- `原因`：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。
![[Pasted image 20231029110219.png]]
## 1.3、头部

### 1.3.1、头部结构

请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头
![[Pasted image 20231029110245.png]]
![[Pasted image 20231029110312.png]]
- 头部字段是 key-value 的形式，key 和 value 之间用:分隔，最后用`CRLF`换行表示字段结束
- HTTP 头字段非常灵活，不仅可以使用标准里的 `Host`、`Connection`等已有头，也可以任意添加自定义头
- 字段名不区分大小写，但首字母大写的可读性更好
- 字段名里不允许出现空格，可以使用连字符-，但不能使用下划线_
- 字段名后面必须紧接着:，不能有空格，而:后的字段值前可以有多个空格
- 字段的顺序是没有意义的，可以任意排列不影响语义
- 字段原则上不能重复，除非这个字段本身的语义允许，例如 `Set-Cookie`

### 1.3.2、常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

- `通用字段`：在请求头和响应头里都可以出现；
- `请求字段`：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
- `响应字段`：仅能出现在响应头里，补充说明响应报文的信息；
- `实体字段`：它实际上属于通用字段，但专门描述 body 的额外信息。对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。

#### 1.3.1.1、Host

它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。

#### 1.3.1.2、User-Agent

请求头字段，它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是Mozilla、Chrome、Safari，企图使用这个字段来互相伪装，导致 User-Agent 变得越来越长，最终变得毫无意义。

#### 1.3.1.3、Date

通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。

#### 1.3.1.4、Server

响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号 Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。

# 2、HTTP请求方法

![[Pasted image 20231029104025.png]]
## 2.1、标准请求方法

1. `GET`：获取资源，可以理解为读取或者下载数据；
2. `HEAD`：获取资源的元信息；
3. `POST`：向资源提交数据，相当于写入或上传数据；
4. `PUT`：类似 POST；
5. `DELETE`：删除资源；
6. `CONNECT`：建立特殊的连接隧道；
7. `OPTIONS`：列出可对资源实行的方法；
8. `TRACE`：追踪请求 - 响应的传输路径。

### 2.1.1、GET/HEAD

GET 方法的含义是请求从服务器获取资源，虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作。例如，在 URI 后使用#，就可以在获取页面后直接定位到某个标签所在的位置；使用`If-Modified-Since`字段就变成了有条件的请求，仅当资源被修改时才会执行获取动作；使用`Range`字段就是范围请求，只获取资源的一部分数据。

HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。

### 2.1.2、POST/PUT

POST 和 PUT 方法向 URI 指定的资源提交数据，数据就放在报文的 body 里。

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是新建的含义，而 PUT 则是修改的含义。

### 2.1.3、DELETE

指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。

### 2.1.4、CONNECT

是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。

### 2.1.5、OPTIONS

方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。

### 2.1.6、TRACE

多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。

## 2.2、扩展方法

此外，还有一些得到了实际应用的请求方法（WebDAV），例如 `MKCOL`、`COPY`、`MOVE`、`LOCK`、`UNLOCK`、`PATCH` 等。如果有合适的场景，你也可以把它们应用到自己的系统里，比如用 LOCK 方法锁定资源暂时不允许修改，或者使用 PATCH 方法给资源打个小补丁，部分更新数据。但因为这些方法是非标准的，所以需要为客户端和服务器编写额外的代码才能添加支持。

## 2.3、安全与幂等

### 2.3.1、安全

按照这个定义，只有 GET 和 HEAD 方法是安全的，因为它们是只读操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是安全的。而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是不安全的。

### 2.3.2、幂等

很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是资源不存在，所以也是幂等的。

按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是替换或更新数据，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

# 3、URI

![](https://secure2.wostatic.cn/static/unT1v3RKi8ovrhqE4ESaiD/untitled.png?auth_key=1698547032-sfxRFDx8b9eG2nc4XXt4An-0-5b6daf89aa1ad2bda13c28185c3789ae)

## 3.1、概念

### 3.1.1、统一资源定位符（Uniform Resource Locator）
![[Pasted image 20231029104312.png]]
- `scheme`：中文叫协议名，表示资源应该使用哪种协议来访问。常见的`http`、`https`、`ftp`、`ldap`、`file`、`news` 等。浏览器根据scheme会调用相应的 HTTP 或者 HTTPS 下层 API。URI 必须提供 scheme。
- `://`：它把 scheme 和后面的部分分离开。
- `用户名密码`：协议名之后、主机名之前的身份信息user:passwd@，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了(RFC7230)，因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。
- `主机名和端口`：资源所在的主机名，通常的形式是host:port，即主机名加端口号。主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号。
- `path`：URI 里 path 采用了类似文件系统目录/路径的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的/风格。URI 的 path 部分必须以/开始。
- `查询参数`：在 path 之后，用一个?开始，但不包含?，表示对资源附加的额外要求。这是个很形象的符号，很明显地表示了查询的含义。查询参数 query 有一套自己的格式，是多个key=value的字符串，这些 KV 值用字符&连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。

### 3.1.2、统一资源名（Uniform Resource Name）

URI 的第二种形式就是`统一资源名(URN)`。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的 URN，就可以将资源四处搬移。通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源。比如，不论资源位于何处（甚至可以将其复制到多个地方），都可以用下列 URN 来命名它：urn:ietf:rfc:2141，URN 仍然处于试验阶段，还未大范围使用。

## 3.2、URI编码

在 URI 里只能使用 ASCII 码，但如果要在 URI 里使用英语以外的语言、某些特殊的 URI，会在 path、query 里出现@&?等起界定符作用的字符，会导致 URI 解析错误，所以，URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为`escape`和`unescape`，俗称`转义`。 URI 转义的规则有点简单粗暴，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个%。例如，空格被转义成%20，?被转义成%3F。而中文、日文等则通常使用 UTF-8 编码后再转义，例如银河会被转义成%E9%93%B6%E6%B2%B3。

> 有了这个编码规则后，URI可以支持任意的字符集用任何语言来标记资源。不过浏览器的地址栏里通常是不会看到这些转义后的乱码的，这实际上是浏览器隐藏了 URI 编码后的结果。

# 4、响应状态码

## 4.1、概述

状态行的结构，有三部分：
![[Pasted image 20231029105234.png]]
- `Version`: HTTP 协议的版本号
- `Reason`: 原因短语，是状态码的简短文字描述，也可以自定义，它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。
- `Status Code`: 状态码，它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，它的含义在于表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态。

## 4.2、状态码

目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。

RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 099 不用，这样状态码的实际可用范围就大大缩小了，由 000999 变成了 100~599。

### 4.2.1、1XX

属于提示信息，是协议处理的中间状态。

我们偶尔能够见到的是`101 Switching Protocols`，它的意思是客户端使用`Upgrade`头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。

### 4.2.2、2XX

表示服务器收到并成功处理了客户端的请求。

- `200 OK`：是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据
- `204 No Content`：是另一个很常见的成功状态码，它的含义与`200 OK`基本相同，但响应头后没有 body 数据
- `206 Partial Content`：**是 HTTP 分块下载或断点续传的基础**，在客户端发送`范围请求`、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分，通常还会伴随着头字段`Content-Range`，表示响应报文里 body 数据的具体范围，供客户端确认，例如`Content-Range: bytes 0-99/2000`，意思是此次获取的是总计 2000 个字节的前 100 个字节（另见：3、范围请求）

### 4.2.3、3XX

重定向，资源位置发生变动，客户端必须用新的 URI 重新发送请求获取资源。参考：2、重定向状态码

- `301 Moved Permanently`：俗称永久重定向，表示请求的资源已经不存在了，需要用新的URI再次访问
- `302 Found`：曾经的描述短语是Moved Temporarily，俗称临时重定向，意思是请求的资源还在，但需要暂时用另一个 URI 来访问
- `304 Not Modified`：它用于 `If-Modified-Since` 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成重定向已到缓存的文件(缓存重定向)

### 4.2.4、4XX

客户端错误，请求报文有误，服务器无法处理，它就是真正的错误码含义了。

- `400 Bad Request`：通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长没有明确说，只是一个笼统的错误，所以，应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码
- `403 Forbidden`：表示服务器禁止访问资源。例如信息敏感、法律禁止等
- `404 Not Found`：资源在本服务器上未找到，无法提供给客户端
- `405 Method Not Allowed`：不允许使用某些方法操作资源，例如不允许 POST 只能 GET
- `406 Not Acceptable`：资源无法满足客户端请求的条件，例如请求中文但只有英文
- `408 Request Timeout`：请求超时，服务器等待了过长的时间
- `409 Conflict`：多个请求发生了冲突，可以理解为多线程并发时的竞态
- `413 Request Entity Too Large`：请求报文里的 body 太大
- `414 Request-URI Too Long`：请求行里的 URI 太大
- `429 Too Many Requests`：客户端发送了太多的请求，通常是由于服务器的限连策略
- `431 Request Header Fields Too Large`：请求头某个字段或总体太大

### 4.2.5、5XX

服务器在处理请求时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。

- `500 Internal Server Error`：与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界，能够防止黑客的窥探或者分析。
- `501 Not Implemented`：表示客户端请求的功能还不支持，这个错误码比 500 要温和一些，和即将开业，敬请期待的意思差不多，不过具体什么时候开业就不好说了。
- `502 Bad Gateway`：通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。
- `503 Service Unavailable`：表示服务器当前很忙，暂时无法响应服务，503 是一个临时的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个`Retry-After`字段，指示客户端可以在多久以后再次尝试发送请求。
